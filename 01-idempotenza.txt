L'idempotenza
=============

Una delle caratteristiche fondamentali dei sistemi di deploy automatico è che 
semplicemente ci piacerebbe poter avviare (senza pensieri) lo script anche 
seconda volta dopo la prima.

Il punto è che uno script di deploy è veramente automatico solo se posso 
avviarlo senza pensieri ogni volta che voglio, anche una volta di seguito 
all'altra e l'effetto dei due avvii deve essere lo stesso di un avvio solo.

Non è che il primo deploy va bene, e poi al secondo si spacca tutto solo perché 
tenta di ricreare su DB una tabella che aveva già ricreato la volta precedente.

Non è che dopo la seconda (o terza) esecuzione mi ritrovo due utenti di test 
nel sistema, o altri duplicati delle cose che dovevano essere preparate dallo 
script di deploy.

Non è che dopo il primo deploy automatico prima di lanciare il secondo deploy 
automatico io debba fare dei passi manuali per preparare l'ambiente ad essere 
modificato "automaticamente" dallo script di deploy.

A questo concetto molto pratico è stato dato lo stesso nome usato in matematica 
per indicare quelle operazioni il cui effetto di ripetute applicazioni è lo 
stesso di un unica applicazione: Idempotenza.

Alcuni degli strumenti di deploy automatico e provisioning hanno interi sistemi 
e astrazioni per gestire l'idempotenza.

Io credo che in realtà l'idempotenza, se spiegata bene, sia un concetto molto 
semplice da spiegare e anche da implementare.

L'idempotenza si spiega così: "è come lavarsi le mani".
Se hai le mani sporche o pulite e poi vai a lavartele dopo sono pulite.
Se te le lavi due, tre, quattro volte di seguito, poi sono sempre pulite.

Invece infornare una torta per cuocerla non è un'operazione idempotente, la 
prima volta che la cuoci la torta va bene, la seconda volta che la inforni la 
bruci.

Di seguito mostrerò come ottenere l'idempotenza negli script di deploy usando 
gli strumenti già presenti nel sistema operativo, senza impazzire 
con framework complessi che richiedono mille dipendenze.


Demo
====

  - problema semplificato
  - analizziamo il problema nell'esecuzione di un unico semplice comando
  - una volta che abbiamo capito il problema e le soluzioni con un solo comando possiamo applicare gli stessi principi a qualsiasi script più complesso
  - Immaginiamoci che l'unica cosa che faccia il nostro sistema di deploy è la creazione di una cartella
  - (un po' poco per un vero script di deploy però l'esempio serve per ridurre il numero di cose da capire per capire i concetti, più avanti vedremo come estendere il concetto a script in condizioni realistiche: migliaia di operazioni diverse sulle macchine target)
  - Ecco il nostro script contiene solo questo comando:
    
    $ mkdir cartella 
    $ 
    
  - Se usato "from scratch" (su un sistema appena inizializzato) sicuramente funziona.
  - Cosa succede se avviamo il comando una seconda volta?
    
    $ mkdir cartella
    mkdir: cartella: File exists
    $ 
    
  - Come si può risolvere questo problema?
  - Ascoltare risposte dal pubblico.
  
  - I 4 metodi per ottenere idempotenza negli script di deploy
  - 1) il metodo della ruspa: fare piazza pulita prima di apportare la modifica
    e.g.:
      rm -Rf cartella && mkdir cartella
  - 3) il metodo del minimo sforzo "se non c'è bisogno non lo faccio", a.k.a. "metodo della sonda"
      (e.g. "test -d cartella || mkdir cartella")
  - 4) usare il metodo della sovascrittura (non sempre possibile)
      (e.g. non è possibile con la creazione della cartella)
  - 4) usare l'idempotenza built-in in alcuni comandi
      (e.g. "mkdir -p cartella")
      - richiede conoscenza dei comandi (man mkdir)
      - a volte è la soluzione più pulita

  - Vediamo altri esempi con altri comandi:
  - "nginx --version || apt-get install nginx -y"
    - è un caso di idempotenza con sonda
  - ln -s source target
    - non è idempotente
  - ln -sf source target
    - ha un certo grado di idempotenza
    - è un idempotenza built-in con sovrascrittura
  - rm -Rf target && ln -s source target
    - qui usiamo il metodo della ruspa
    - ha un grado di idempotenza più alto del precedente

  - Alcuni comandi sono idempotenti di natura:
  - chown -R qmaill:root /var/log/qmail
  - chmod -R 750 /var/log/qmail 
  
  - Un problema tipico dell'idempotenza é questo:
    - "Aggiungere una riga al file /etc/hosts"
  - Questa è la versione non idempotente:
    - echo '127.0.0.1 local.e-commerce.com' >> /etc/hosts
    - non è idempotente
    - ci sarebbe da dire qualcosa riguardo ai permessi, ma eventualmente lo vediamo dopo
  - fgrep -q '127.0.0.1 local.e-commerce.com' /etc/hosts || echo '127.0.0.1 local.e-commerce.com' >> /etc/hosts
    - questa è la versione idempotente
    - è idempotente per sonda
  - se vi sembra poco leggibile si può anche definire una funzione che riduce la duplicazione:
    add_line_just_once() {
      local line="$1"
      local file="$2"
      fgrep -q "$line" "$file" || echo "$line" >> "$file"
    }
  - e poi si può usare:
    add_line_just_once '127.0.0.1 local.e-commerce.com' /etc/hosts

  - Esempio della creazione di un bare repository git:
  - versione non idempotente:
    OK $ mkdir repo.git && ( cd repo.git && git init --bare )
    Initialized empty Git repository in /Users/andrea/just-bash/repo.git/
    OK $ mkdir repo.git && ( cd repo.git && git init --bare )
    mkdir: repo.git: File exists
    OK $
  - versione idempotente:
    OK $ rm repo.git -Rf # pulizia
    OK $ mkdir -p repo.git && ( cd repo.git && git init --bare )
    Initialized empty Git repository in /Users/andrea/just-bash/repo.git/
    OK $ mkdir -p repo.git && ( cd repo.git && git init --bare )
    Reinitialized existing Git repository in /Users/andrea/just-bash/repo.git/
    KO $
  - Questo repository ci serve per il prossimo esercizio:
  - Però prima facciamo in modo che contenga qualcosa:
  - Esempio della creazione della working copy
    - dato un repository creato con:
      rm -Rf repo.git &&
      mkdir repo.git &&
      ( cd repo.git && git init -q --bare) &&
      { rm -Rf work &&
        git clone -q repo.git work &&
        (cd work &&
        touch one-file &&
        git add one-file &&
        git commit -q -m add one-file &&
        git push -q ) && rm -Rf work }
    - git -C repo.git log
    - vogliamo clonarlo in una working copy:
    - questa è la versione non idempotente:
      $ git clone repo.git working-copy
    - questa è la versione idempotente con ruspa:
      OK $ rm -Rf working-copy && git clone -q repo.git working-copy
      OK $ rm -Rf working-copy && git clone -q repo.git working-copy
    - La versione idempotente con ruspa va bene ma a volte potrebbe essere troppo costosa in termini di prestazioni
  - Questa è la versione idempotente performante
  - Ve la faccio vedere ma non spaventatevi:
  - mkdir -p working-copy && (
    cd working-copy && 
    git init && 
    ( git remote rm origin || true ) && 
    git remote add -f origin ../repo.git && 
    git fetch -u origin master &&
    git checkout master
    )
  - facciamo pulizia
    OK $ rm repo.git -Rf
    OK $ rm working-copy -Rf


