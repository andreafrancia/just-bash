Checklist:

  - (off the record) spegnere Dropbox
  - (on-the-net) fare restart della vagrant
    vagrant destroy -f && vagrant up
  - oppure fare il provision
    vagrant provision
  - reset
    unalias d; unalias c; unalias t; unalias s
    git rm -f \
      vagrant.ssh-config \
      script/deploy
    git commit -m "Reset" -a
  - check esistenza 'Host default' da ~/.ssh-config (con grep)
  - ricordarsi di far partire la registrazione

Problema da risolvere:

  - Scrivere uno script di deploy che faccia il deploy automatico di un software su un server
  - Il server è una macchina Vagrant accessibile con "vagrant ssh"
  - La macchina dovrebbe essere già stata creata e provisionata
  - Il software da installare cambierà nel tempo, come succede nella realtà.
  - Immaginatevi che all'inizio sia un software molto semplice

Regole:

  - si implementa una feature alla volta ("wip = 1")
  - abbiamo un elenco di feature ("To Do List")
  - le feature fatte le marchiamo DONE
  - prima di partire con l'implementazione spiegare il test
  - se nascono delle nuove esigenze si aggiorna la todo list

Problema:

  - il deploy script tocca la macchina (uname -a)
  - il deploy script usa ssh puro (non vagrant ssh), lo scopo finale è avere uno script che può funzionare anche in produzione (dove c'è SSH ma non c'è Vagrant)
  - il deploy script installa una pagina statica (hello-world.txt)
  - il deploy script installa la pagina statica su nginx
  - il software da installare è una classe .java
  - la macchina target risponde in HTTP sulla sua porta 80
  - la macchina risponde in HTTP su 8080
  - la servlet per funzionare richiede MySQL
  - la servlet che richiede il Sun di Oracle
  - per testare la servlet bisogna fare una fixture sul database
  - la configurazione di connessione al database cambia dall'ambiente di produzione a quello di produzione
  - deployare una specifica versione

L'idempotenza
=============
  
  - problema semplificato
  - analizziamo il problema nell'esecuzione di un unico semplice comando
  - una volta che abbiamo capito il problema e le soluzioni con un solo comando possiamo applicare gli stessi principi a qualsiasi script più complesso
  - Immaginiamoci che l'unica cosa che faccia il nostro sistema di deploy è la creazione di una cartella
  - (un po' poco per un vero script di deploy però l'esempio serve per ridurre il numero di cose da capire per capire i concetti, più avanti vedremo come estendere il concetto a script in condizioni realistiche: migliaia di operazioni diverse sulle macchine target)
  - Ecco il nostro script contiene solo questo comando:
    
    $ mkdir cartella 
    $ 
    
  - Se usato "from scratch" (su un sistema appena inizializzato) sicuramente funziona.
  - Cosa succede se avviamo il comando una seconda volta?
    
    $ mkdir cartella
    mkdir: cartella: File exists
    $ 
    
  - Come si può risolvere questo problema?
  - Ascoltare risposte dal pubblico.
  
  - I 4 metodi per ottenere idempotenza negli script di deploy
  - 1) il metodo della ruspa: fare piazza pulita prima di apportare la modifica
    e.g.:
      rm -Rf cartella && mkdir cartella
  - 3) il metodo del minimo sforzo "se non c'è bisogno non lo faccio", a.k.a. "metodo della sonda"
      (e.g. "test -d cartella || mkdir cartella")
  - 4) usare il metodo della sovascrittura (non sempre possibile)
      (e.g. non è possibile con la creazione della cartella)
  - 4) usare l'idempotenza built-in in alcuni comandi
      (e.g. "mkdir -p cartella")
      - richiede conoscenza dei comandi (man mkdir)
      - a volte è la soluzione più pulita

  - Vediamo altri esempi con altri comandi:
  - "nginx --version || apt-get install nginx -y"
    - è un caso di idempotenza con sonda
  - ln -s source target
    - non è idempotente
  - ln -sf source target
    - ha un certo grado di idempotenza
    - è un idempotenza built-in con sovrascrittura
  - rm -Rf target && ln -s source target
    - qui usiamo il metodo della ruspa
    - ha un grado di idempotenza più alto del precedente

  - Alcuni comandi sono idempotenti di natura:
  - chown -R qmaill:root /var/log/qmail
  - chmod -R 750 /var/log/qmail 
  
  - Un problema tipico dell'idempotenza é questo:
    - "Aggiungere una riga al file /etc/hosts"
  - Questa è la versione non idempotente:
    - echo '127.0.0.1 local.e-commerce.com' >> /etc/hosts
    - non è idempotente
    - ci sarebbe da dire qualcosa riguardo ai permessi, ma eventualmente lo vediamo dopo
  - fgrep -q '127.0.0.1 local.e-commerce.com' /etc/hosts || echo '127.0.0.1 local.e-commerce.com' >> /etc/hosts
    - questa è la versione idempotente
    - è idempotente per sonda
  - se vi sembra poco leggibile si può anche definire una funzione che riduce la duplicazione:
    add_line_just_once() {
      local line="$1"
      local file="$2"
      fgrep -q "$line" "$file" || echo "$line" >> "$file"
    }
  - e poi si può usare:
    add_line_just_once '127.0.0.1 local.e-commerce.com' /etc/hosts

  - Esempio della creazione di un bare repository git:
  - versione non idempotente:
    OK $ mkdir repo.git && ( cd repo.git && git init --bare )
    Initialized empty Git repository in /Users/andrea/just-bash/repo.git/
    OK $ mkdir repo.git && ( cd repo.git && git init --bare )
    mkdir: repo.git: File exists
    OK $
  - versione idempotente:
    OK $ rm repo.git -Rf # pulizia
    OK $ mkdir -p repo.git && ( cd repo.git && git init --bare )
    Initialized empty Git repository in /Users/andrea/just-bash/repo.git/
    OK $ mkdir -p repo.git && ( cd repo.git && git init --bare )
    Reinitialized existing Git repository in /Users/andrea/just-bash/repo.git/
    KO $
  - Questo repository ci serve per il prossimo esercizio:
  - Però prima facciamo in modo che contenga qualcosa:
  - Esempio della creazione della working copy
    - dato un repository creato con:
      rm -Rf repo.git &&
      mkdir repo.git &&
      ( cd repo.git && git init -q --bare) &&
      { rm -Rf work &&
        git clone -q repo.git work &&
        (cd work &&
        touch one-file &&
        git add one-file &&
        git commit -q -m add one-file &&
        git push -q ) && rm -Rf work }
    - git -C repo.git log
    - vogliamo clonarlo in una working copy:
    - questa è la versione non idempotente:
      $ git clone repo.git working-copy
    - questa è la versione idempotente con ruspa:
      OK $ rm -Rf working-copy && git clone -q repo.git working-copy
      OK $ rm -Rf working-copy && git clone -q repo.git working-copy
    - La versione idempotente con ruspa va bene ma a volte potrebbe essere troppo costosa in termini di prestazioni
  - Questa è la versione idempotente performante
  - Ve la faccio vedere ma non spaventatevi:
  - mkdir -p working-copy && (
    cd working-copy && 
    git init && 
    ( git remote rm origin || true ) && 
    git remote add -f origin ../repo.git && 
    git fetch -u origin master &&
    git checkout master
    )
  - facciamo pulizia
    OK $ rm repo.git -Rf
    OK $ rm working-copy -Rf
  

Notes:

  - trucco del cd tra parentesi
  - GIT_SSH_COMMAND="ssh -F vagrant.ssh-config" \
      git push default:/home/vagrant/repo.git master
  - (feedback) versione nel Vagrantfile
  - how to install git:
    - git --version || sudo apt-get install git-core -y
  - copiare un file usando rsync over SSH:
    - rsync hello-world default:
  - how to create a bare repository:
    - ssh default 'mkdir -p repo.git && cd repo.git && git init --bare'
  - how to create the working copy (non idempotent)
    - git clone repo.git/ working-copy
  - java servlet compiling:
    - javac -cp lib/servlet-api.jar example/HelloWorld.java
  - copy .class:
    - ssh default 'ls /var/lib/tomcat7/webapps/ROOT/WEB-INF/classes/HelloWorld.class'
  - check tomcat
    - ls downloads/apache-tomcat-7.0.68.tar.gz
  - tomcat has been downloaded from here:  
    - wget http://it.apache.contactlab.it/tomcat/tomcat-7/v7.0.68/bin/apache-tomcat-7.0.68.tar.gz
  - tomcat directories:
    - /etc/default/tomcat7 (file di configurazione)
    - /usr/share/tomcat7-admin/manager (applicazione manager)
    - /usr/share/tomcat7/lib (librerie tomcat)
    - /usr/lib/jvm/java-8-oracle
    - /var/lib/tomcat7/webapps
  - modi per risolvere: zsh: exec format error: script/deploy
    - mettere :
    - mettere true
    - mettere #!/bin/bash
  - Prompt
    - barra verde/rossa nel prompt della Bash:
      - PS1="\`if [ \$? = 0 ]; then printf \[\e[32m\]; else printf \[\e[31m\]; fi; printf \\$\e[0m\] \` $PS1"
    - prompt semplice in Zsh:
      - PS2="> "
    - Zsh:
      export PROMPT=$'%{\e[0;%(?.32.31)m%}'$'%(?.OK.KO)'" \$"$'%{\e[0m%}'" " # testing prompt
      export PS2="> " # simple continuation prompt
  - linea Vagrantfile per forwardare tomcat:
    - config.vm.network "forwarded_port", guest: 8080, host: 8080
  - l'uso di SSH config
    - vagrant ssh-config >> ~/.ssh/config
  - ssh -i .vagrant/machines/default/virtualbox/private_key -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no  -p 2222 -l vagrant  localhost
  - git log  --oneline --graph --color
  - git config --global alias.st "status"
  - data dir: - vagrant ssh -c "ls /vagrant"
  - curl --silent --output /dev/null --write-out "%{http_code}"  "http://localhost:8080/"
  - deploy della servlet:
    cp /vagrant/.../HelloWorld.class /var/lib/tomcat7/webapps/ROOT

Altre note:

  - tutorial http://www.tutorialspoint.com/servlets/servlets-first-example.htm

mkdir -p /var/lib/tomcat7/webapps/ROOT/WEB-INF/web.xml
cat >/var/lib/tomcat7/webapps/ROOT/WEB-INF/web.xml << \'
<servlet>
   <servlet-name>HelloWorld</servlet-name>
   <servlet-class>HelloWorld</servlet-class>
</servlet>

<servlet-mapping>
   <servlet-name>HelloWorld</servlet-name>
   <url-pattern>/HelloWorld</url-pattern>
</servlet-mapping>
'

Per installare mysql senza dover mettere la password:

    sudo debconf-set-selections <<< 'mysql-server mysql-server/root_password password my_password'
    sudo debconf-set-selections <<< 'mysql-server mysql-server/root_password_again password my_password'
    sudo apt-get -y install mysql-server

Per sapere le selections:

    sudo apt-get install -y debconf-utils
    debconf-get-selections
  

Notes from an acient test-all script:

set -o errexit

source ~/.zshrc.local

# quando però gli passo il messaggio usa quello per fare commmit
wiki_commit "Messaggio" echo > actual
diff -u <(cat << \"
cd /Users/andrea/Dropbox/wiki
git commit -am "Messaggio"
"
) actual

# quando non gli passo niente, a parte (echo), il messaggio di commit è "."
wiki_commit echo > actual
diff -u <(cat << \"
cd /Users/andrea/Dropbox/wiki
git commit -am .
"
) actual

# test math 1+1 == 2
echo "1+1" | bc > actual
diff -u <(echo "2") actual

- TODO deploy should install the servlet:
  - curl --silent --output /dev/null  --write-out "%{http_code}"  "http://localhost:8080/hello-world"
  - -> 200 not 404

